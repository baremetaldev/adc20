<!doctype html>
<html>
    <head>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

        <title>reveal.js</title>

        <link rel="stylesheet" href="reveal.js/dist/reset.css">
        <link rel="stylesheet" href="reveal.js/dist/reveal.css">
        <link rel="stylesheet" href="reveal.js/dist/theme/white.css" id="theme">

        <!-- Theme used for syntax highlighted code -->
        <link rel="stylesheet" href="reveal.js/plugin/highlight/monokai.css" id="highlight-theme">
    </head>
    <body>
        <div class="reveal">
            <div class="slides">
                <!-- <section><p>hitchhiker's guide to embedded audio</p></section> -->
                <section data-background="assets/titlecard.jpg"></section>
                <section data-markdown>
                    <textarea data-template data-separator-notes="^Note:">
                        ### intro
                        _"DON'T PANIC"_

                        ― Douglas Adams, The Hitchhiker's Guide to the Galaxy (applies to all quotes)
                        Note: I'd like to go through the process of creating a digital audio device from a high-level
                        perspective. I will attempt to show most of the things you'll
                        want to learn, or skills that you'll want to look for when hiring.
                    </textarea>
                </section>
                <!-- <section data-markdown>
                    <textarea data-template data-separator-notes="^Note:">
                        ### this talk is for ...
                        - people looking to turn software into hardware
                        - folks exploring hardware
                        - hobbyists with a small/no budget
                        Note: This talk is for anyone generally interested in embedded systems.
                        People looking to turn a successful software product into a real piece of kit.
                        And I want to include hobbyists here, so all the tools I'll show are
                        free to use, I think most of them are open source as well.
                    </textarea>
                </section> -->
                <section data-markdown>
                    <textarea data-template data-separator-notes="^Note:">
                        - **electronics** - _mostly harmless_
                        - **baremetal programming** - _the restaurant at the end of the universe_
                        - **embedded programming** - _and another thing..._
                        - **audio programming** - _life, the universe and everything_
                        - **output** - _so long, and thanks for all the fish_
                        Note: I've split my talk into a few chunks. Electronics, of course, couple of chapters on programming, and a little about audio outputs.
                    </textarea>
                </section>
                <section data-markdown>
                    <textarea data-template data-separator-notes="^Note:">
                        _"Er, excuse me, who am I?"_
                            
                        ― Douglas Adams, The Hitchhiker's Guide to the Galaxy
                        Note: A little about myself and why you should listen to me.
                        I've been an embedded developer for over a decade in the audio industry. I'm currently working freelance.
                    </textarea>
                </section>
                <section>
                    <img src="assets/cadac-jtype.jpg" height="600">
                    <aside class="notes">I started out at Cadac working on big theatre mixing consoles.</aside>
                </section>
                <section>
                    <img src="assets/roli-smk.jpg" height="600">
                    <aside class="notes">More recently working at ROLI working on everything from the Seaboard RISE onwards.</aside>
                </section>
                <section>
                    <img src="assets/NovaNeon.jpg">
                    <aside class="notes">... and I'm a musician, you should check out my band Nova Neon</aside>
                </section>
                <section>
                    <p>novaneon.com</p>
                    <img src="assets/novaneon-photo.jpg" height="600">
                    <aside class="notes">we've got another recording coming up in december, assuming there is a december</aside>
                </section>
                <section data-background-iframe="https://www.youtube.com/embed/0Qig-We5MyA?controls=0&amp;mute=true&amp;autoplay=true&amp;playlist=0Qig-We5MyA&amp;loop=1">
                    <aside class="notes">
                        I've done a couple of other talks in the past.
                        This one, crash synth, was an ADC lightning talk about a hardware synth that works by modulating how often it crashes.
                    </aside>
                </section>
                <section>blinky
                    <pre><code data-trim data-noescape><script type="text/template">
    *reinterpret_cast<unsigned*> (0x4002'1014) = 0x0002'0014;
    *reinterpret_cast<unsigned*> (0x4002'101c) = 0x0000'0001;

    *reinterpret_cast<unsigned*> (0x4800'0000) = 0xa800'0800;
    *reinterpret_cast<unsigned*> (0x4800'0020) = 0x0010'0000;
    *reinterpret_cast<unsigned*> (0x4000'0028) = 0x0000'0f9f;
    *reinterpret_cast<unsigned*> (0x4000'002c) = 0x0000'03e7;
    *reinterpret_cast<unsigned*> (0x4000'0034) = 0x0000'03e7;
    *reinterpret_cast<unsigned*> (0x4000'0020) = 0x0000'0001;
    *reinterpret_cast<unsigned*> (0x4000'0018) = 0x0000'0038;

    *reinterpret_cast<unsigned*> (0x4000'0000) = 0x0000'0001;

    asm volatile ("wfi");   // 'wait for interrupt' (sleep)
                    </script></code></pre>
                    <aside class="notes">
                        Note: I also did a short talk for London C++ meetup, which was all about some of the challenges of writing embedded C++ code.
                        Please don't attempt to parse this code right now. The programmers among you might be trying to figure
                        out what this does, but it's not for human consumption.
                        This code was a snippet I used to make a point about how silly embedded code can be.
                        It's my take on a blinky program, which just flashes an LED on a development kit at 1Hz, though this one does so with the CPU asleep.
                    </aside>
                </section>
                <section data-markdown>
                    <textarea data-template data-separator-notes="^Note:">
                        ### jargon
                        _"Hey, you sass that hoopy Ford Prefect? There's a frood who really knows where his towel is."_
                        Note: Before we begin, a quick note about jargon.
                        There may be a fair amount of nonsense words or phrases.
                    </textarea>
                </section>
                <section data-markdown>
                    <textarea data-template data-separator-notes="^Note:">
                        ### acronyms (even multi-dimensional)
                        
                        - VHDL
                        
                            &#8593; VHSIC hardware description language
                        
                            &#8593;&#8593; very high speed integrated circuit
                        Note: And an extreme amount of acronyms. Including some arguably time saving multi-dimensional acronyms.
                        If there's anything that you don't understand, please just ask.
                    </textarea>
                </section>
                <section data-markdown>
                    <textarea data-template data-separator-notes="^Note:">
                        ![](assets/origin.svg)
                        Note: A few years ago, I embarked on an ambitious little side project.
                        I had decided to spend some spare time building a tiny digital hardware synthesiser,
                        completely from scratch.
                        I'm sure you've all done something similar.
                        I imagined it would look something like a usb stick with a headphone socket on it.
                    </textarea>
                </section>
                <section data-markdown data-transition="fade">
                    <textarea data-template data-separator-notes="^Note:">
                        ![](assets/origina.svg)
                        Note: My design started with a microcontroller.
                    </textarea>
                </section>
                <section data-markdown data-transition="fade">
                    <textarea data-template data-separator-notes="^Note:">
                        ![](assets/originb.svg)
                        Note: And I added a digital audio converter with a headphone amp for
                        my output.
                    </textarea>
                </section>
                <section data-markdown data-transition="fade">
                    <textarea data-template data-separator-notes="^Note:">
                        ![](assets/originc.svg)
                        Note: Then I added usb, so that I could get MIDI control info from a host pc and possibly send audio back.
                        Along with some basic volume controls so that I didn't destroy my eardrums while testing.
                        So far, so good, arguably I should have stopped here. But no.
                        I went a little off the trail and thought, well, what if my synth needs
                        samples? Maybe it's a granular synth or something.
                        Where will it store those samples? 
                    </textarea>
                </section>
                <section data-markdown data-transition="fade">
                    <textarea data-template data-separator-notes="^Note:">
                        ![](assets/origind.svg)
                        Note: So I added an SD card slot and a RAM memory expansion.
                        Getting pretty complicated now, but it's not crazy.
                    </textarea>
                </section>
                <section data-markdown>
                    <textarea data-template data-separator-notes="^Note:">
                        ![](assets/schematic.jpg)

                        \* not the actual schematic
                        Note: I then set about creating an electronic schematic.
                        Ignore this schematic, this is just something I found on the internet.
                    </textarea>
                </section>
                <section data-markdown>
                    <textarea data-template data-separator-notes="^Note:">
                        ![](assets/pcblayout.png)

                        \* not the actual pcb
                        Note: ... and laying out a circuit board.
                    </textarea>
                </section>
                <!-- <section data-markdown>
                    <textarea data-template data-separator-notes="^Note:">
                        Note: ... soldering all the components.
                    </textarea>
                </section> -->
                <section data-background-iframe="https://www.youtube.com/embed/Y957rQl7cx4?controls=0&amp;start=200&amp;mute=true&amp;autoplay=true&amp;loop=true">
                    <aside class="notes">
                        ... soldering all the components.
                        Again, this isn't my board.
                        Unfortunately I can't share this project with you, 
                        but I can share my workflow and some of the knowledge you might need
                        to do something like this yourself.
                    </aside>
                </section>
                <!-- <section data-markdown>
                    <textarea data-template data-separator-notes="^Note:">
                        Note: By the time I was done, and reached the point where
                        I actually had to program this thing,
                        I realised that I had missed something important.
                        Something that could have saved me a lot of time.
                    </textarea>
                </section>
                <section data-markdown>
                    <textarea data-template data-separator-notes="^Note:">
                        Note: There's a bunch of arduinos, raspberry pis and dev kits that
                        already have all this working, and at a fraction of the cost that I could
                        build it myself.
                        For me, maybe the real reason for doing this project was that it's
                        fun to do hardware. But if I was going to do a project like this
                        right now I would do things a little differently.
                    </textarea>
                </section>
                <section data-markdown>
                    <textarea data-template data-separator-notes="^Note:">
                        Note: I'd grab a dev kit, let's say this ST kit, it has pretty much
                        the same design as my original. And I'd prototype my synth on here,
                        making use of all the tools that come with the kid.
                    </textarea>
                </section> -->
                <section>
                    <p>workflow</p>
                    <img src="assets/workflow.svg">
                    <aside class="notes">
                        Here's an example workflow. This isn't a full workflow, I've
                        left out the fact that you'll probably do multiple revisions of everything
                        and the fact that eventually you'll have to do it all again in order to
                        get a product through manufacturing, but that's for another talk.
                        You'll probably begin with a basic design or concept, figure out what you want to make.
                        Then some hardware and firmware prototyping. Here, rather than building something
                        from scratch, save yourself some pain and use an already working development kit,
                        or put it together using arduinos or raspberry pis. You can also prototype your
                        firmware code using library code or code provided by component manufacturers.
                        This code may or may not make it into your final product, that's up to you.
                        Once you're happy with your prototype you can get into your proper schematics and
                        printed circuit board designs. You'll have a head start here as your prototype
                        hardware will serve as a useful reference.
                    </aside>
                </section>
                <section data-markdown>
                    <textarea data-template data-separator-notes="^Note:">
                        ### concept
                        ![](assets/concept.jpg)
                        Note: Right, concept. What kind of device shall we build?
                    </textarea>
                </section>
                <section>
                    <p>audio interface</p>
                    <img src="assets/audiointerface.svg">
                    <aside class="notes">
                        Maybe we want to build an audio interface, perhaps we've located some niche,
                        like tubes sticking out of the top or maybe there just aren't enough of these around.
                        We might have microcontroller or a microprocessor at the heart.
                        An analogue to digital converter bringing audio in,
                        a digital to analogue converter sending audio back out. A few physical
                        controls, level controls for example. Along with a USB, or some sort of interface
                        to a host computer, sending and receiving audio or control data.
                        Doesn't have to be USB, it could be bluetooth, HDMI whatever.
                    </aside>
                </section>
                <section>
                    <p>effects pedal</p>
                    <img src="assets/effectspedal.svg">
                    <aside class="notes">
                        Perhaps we want to make an effects pedal. Bit simpler this time
                        around. We might have audio coming in via an analogue filter into
                        our processor via a converter. Maybe foot pedals for controls and
                        the DAC on the output side sending the audio back out.
                    </aside>
                </section>
                <section>
                    <p>synth</p>
                    <img src="assets/synth.svg">
                    <aside class="notes">
                        Or maybe we just want to make a synth. A bunch of controls, could be
                        knobs, a touch screen, whatever you like. The processor will generate
                        our audio and send it out via the DAC.
                    </aside>
                </section>
                <section data-markdown>
                    <textarea data-template data-separator-notes="^Note:">
                        ### electronics
                        _"Perhaps I'm old and tired, but I always think that the chances of finding out what really is going on are so absurdly remote that the only thing to do is to say hang the sense of it and just keep yourself occupied."_
                        Note: I want share a little about analogue electronics, schematics and digital circuits.
                    </textarea>
                    <aside class="notes">

                    </aside>
                </section>
                <!-- <section><img src="assets/b12n-1962.gif" height="600"></section> -->
                <section>
                    <p>analogue</p>
                    <img src="assets/618px-Modern_handbuilt_analogue_synthesizer.jpg" height="600">
                    <aside class="notes">
                        First, what we call the analogue domain. This is where our audio system begins and ends.
                    </aside>
                </section>
                <!-- <section>
                    <p>analogue</p><img src="assets/earth.webp" height="600">
                    <aside class="notes">
                        The real world exists in the analogue domain, our electronics will interact with the real world via the analogue domain.
                    </aside>
                </section> -->
                <section>
                    <p>mics/sensors</p><img src="assets/sensor.jpg" height="600">
                    <aside class="notes">
                        We might start out by measuring the outside world.
                        I'm sure we're all familiar with microphones, converting vibrations in the air into electrical signals.
                        Or we may have sensors reading electrical signals or temperature.
                    </aside>
                </section>
                <section><p>faders/pots/inputs/outputs</p><img src="assets/audio.jpg" height="600">
                    <aside class="notes">Also, I've sure most of you have used faders and pots to control your gear. Input and output jacks to wire up your speakers etc.</aside>
                </section>
                <section><img src="assets/analogue.svg">
                    <aside class="notes">
                        The analogue parts of our system comprise of arguably the most important parts.
                        Our power supply keeps us ticking, and the efficiency and noise of the power supply effects the whole system.
                        Analogue filters are our first line of difference against unwanted signals and side effects.
                    </aside>
                </section>
                <section>
                    <p>testing & diagnostics</p>
                    <aside class="notes">Note: It would be amiss of me not to mention how electronics are tested and issues diagnosed.</aside>
                </section>
                <section data-background="assets/oscilloscope.jpg">
                    <aside class="notes">
                        One tool in the arsenal is the oscilloscope.
                        Oscilloscopes allow you to directly probe your electronics circuit to inspect and analyse the actual signals.
                        This is how you can figure out what's really happening in your circuit.
                        Scopes are very expensive, so if you don't have the budget you can probably hire one,
                        or you can get USB scopes which don't have a screen. They tend to be a lot cheaper, if not quite as good as the real thing.
                        Other equipment might include audio signal analysers such as prism sound's dscope or audio precision gear.
                        Those are industry standard, i.e. expensive, pieces of equipment which you'll likely just want to hire out if/when you need them.
                    </aside>
                </section>

                <!-- <section><img src="assets/b12n-1962.gif" height="600"></section> -->
                <!-- <section><p>typical input example</p><p>mic amp</p></section>
                <section data-markdown>
                    <textarea data-template data-separator-notes="^Note:">
                        ### basic components
                        - resistors
                        - capacitors
                        - transistors
                    </textarea>
                </section>
                <section data-markdown>
                    <textarea data-template data-separator-notes="^Note:">
                        ### op amps
                    </textarea>
                </section>
                <section><p>filters</p></section>
                <section data-markdown>
                    <textarea data-template data-separator-notes="^Note:">
                    </textarea>
                </section>
                <section><p>power supply</p></section>
                <section><p>noise</p></section>
                <section><p>filtering</p></section>
                <section><p>linear</p></section>
                <section><p>modern switch-mode</p></section>
                <section><p>testing</p></section>
                <section><p>oscilloscopes</p></section>
                <section><p>audio test equipment</p></section>
                <section><p>diagnosis</p></section> -->
                <!--  -->
                <section>
                    <p>schematics</p>
                    <aside class="notes">
                        In order to go any further we need to know the language of electronics and circuits.
                        Schematics are a visual design language which can describe how our components are connected and give an idea what they'll do.
                    </aside>
                </section>
                <!-- <section>
                    <img src="assets/b12n-1962.gif" height="600">
                    <aside class="notes">
                        This is a schematic close to my heart. When I was a teenager, my dad built me a bass amp based on this circuit.
                        It's the circuit for a classic ampeg b-15. Don't worry about trying to read or understand
                        this, you're pretty unlikely to have tubes in your designs.
                        The schematic itself hints at some fairly unusual features.
                        If you look at channel 2, you can see this input jack feeds into a tube and gets something like a 30db boost.
                        So before we've touched any controls, we could already be clipping going into the next tube stage.
                        Terrible thing to do, except that it's one of the reasons why this thing sounds so good, forcing the tube to distort in a most pleasing manor.
                    </aside>
                </section> -->
                <!-- <section data-markdown>
                    <textarea data-template data-separator-notes="^Note:">
                        ### basic components
                        - resistors
                        - capacitors
                        - transistors
                        - op amps
                        - integrated circuits (ICs)
                        Note: All the basic components on a schematic have their own corresponding cymbols
                    </textarea>
                </section> -->
                <section data-background="assets/components.jpg">
                    <aside class="notes">
                        All the basic components on a schematic have their own corresponding symbols.
                        These are a few of the most common ones you'll see.
                    </aside>
                </section>
                <section>
                    <p>integrated circuits (ICs)</p>
                    <img src="assets/integratedcircuit.jpg">
                    <aside class="notes">
                        Integrated circuits, or ICs are chips that contains their own circuits,
                        usually complex circuits designed to do specific jobs, made up of all the components we've seen, plus whatever else is needed to do the job.
                        This, for example, is power supply IC that takes a 5V input signal and outputs a 3.3V signal,
                        though as you can see, it requires a few capacitors around it to function correctly.
                        These capacitors are there to filter unwanted frequencies.
                        The components themselves are connected by lines, which correspond to the wires and connections you'll need to make to create this circuit.
                    </aside>
                </section>
                <section data-markdown>
                    <textarea data-template data-separator-notes="^Note:">
                        ### tooling

                        electronic design automation (EDA)
                        - gEDA (geda-project.org)
                        - kiCAD (kicad.org)
                        Note: To get started with schematics you may want to familiarise yourself with EDA software.
                        These tools allow you to design not just your circuit, but will take your circuit design and automate the process of creating a PCB.
                    </textarea>
                </section>
                <section>
                    <p>printed circuit boards (PCBs)</p>
                    <img src="assets/pcb.jpg">
                    <aside class="notes">
                        Once you've completed your schematic design, each of your components will have a physical footprint along with the connections required.
                        Your EDA tool will take this and bring it over to a PCB design editor, allowing you to design a circuit board for your design.
                    </aside>
                </section>
                <section data-background-iframe="https://www.youtube.com/embed/FtWm8Mm6ZPY?controls=0&amp;start=6&amp;mute=true&amp;autoplay=true&amp;loop=true">
                    <aside class="notes">
                        At this point, you need to layout the shape of your board, place all your component footprints and connect everything up.
                        This is a time-lapse of the connections being laid out on a complex multi-layer board.
                        I'm not going to go into any details on this as that's a whole talk in itself.
                    </aside>
                </section>
                <!-- <section data-background="assets/kicad.jpg" data-markdown>
                    <textarea data-template data-separator-notes="^Note:">
                        ### kicad
                        - free-to-use
                        - open source
                        - actively maintained
                        - extensible
                        - youtube vids
                        Note: My EDA tool of choice is Kicad. One thing I really like about kicad is that it's extensible.
                        If you can write a little python, you can automate a lot of what you need to do. Or you may find someone else has already written a plugin that does what you need.
                        Another thing is that there are tonnes of good tutorial videos freely available to teach you how to use it and help you with your designs.
                    </textarea>
                </section> -->
                <section data-markdown>
                    <textarea data-template data-separator-notes="^Note:">
                        ### reference designs
                        - development kit designs
                        - individual component minimum/typical connection circuits and layouts
                        Note: If I was getting started, I would grab kicad and make use of tutorials and reference designs.
                        Often dev kits will come with designs and components themselves may come with recommended circuits and PCB layouts.
                    </textarea>
                </section>
                <section>
                    <p>testing</p>
                    <aside class="notes">
                        There are ways to verify your schematic and PCB designs. Your EDA tools will likely be able to check that you've got everything connected up right, assuming you set this up correctly.
                    </aside>
                </section>
                <section>
                    <p>circuit simulation</p>
                    <aside class="notes">
                        You may even want to simulate parts of your circuit, to be sure that, given certain input signals, you'll get the correct result.
                    </aside>
                </section>
                <section>
                    <p>circuitjs (falstad)</p>
                    <iframe data-src="https://www.falstad.com/circuit/circuitjs.html" width="100%" height="600"></iframe>
                    <aside class="notes">
                        Your EDA tool likely has a simulator built-in, but this is an online one which is fun to play around with.
                        Here you can lay out a simple circuit and look at the expected signals.
                    </aside>
                </section>
                <section>
                    <p>limitations</p>
                    <aside class="notes">
                        Just bare in mind that real components are never perfect,
                        which means the real thing may not come out quite as the simulation suggests,
                        but it should give you a good idea of what you're circuit is going to do.
                    </aside>
                </section>
                <section>
                    <p>digital audio circuits</p>
                    <aside class="notes">
                        How do we turn continuous analogue signals into discreet digital values?
                    </aside>
                </section>
                <section data-markdown>
                    <textarea data-template data-separator-notes="^Note:">
                        ### analogue-to-digital converter (ADC)
                        - successive approximation register (SAR)
                        - sigma-delta modulation
                        Note: There are two common methods for analogue to digital conversion.
                        SAR converters are usually what you'd find on microcontrollers and are well suited to reading sensors.
                        Sigma-delta converters are a continuous, frequency-based algorithm, used commonly for audio.
                    </textarea>
                </section>
                <section data-markdown>
                    <textarea data-template data-separator-notes="^Note:">
                        ### audio ADCs
                        - filters
                        - noise shaping
                        - dithering
                        Note: Audio ADCs in particular, have a few tricks up their sleeves.
                        They'll use filters, because they're only interested in audio frequency range.
                        Noise shaping and dithering are the black magic used to improve conversion accuracy by adding noise back into the system.
                    </textarea>
                </section>
                <section data-markdown>
                    <textarea data-template data-separator-notes="^Note:">
                        ### transport and control
                        - inter-IC sound (I²S)
                        - time division multiplexed audio (TDM)
                        - control communications (I²C, SPI)
                        ![](assets/tdm.jpg)
                        Note: ADC typically communicate their results to a microprocessor or microcontroller.
                        They'll do this using signals following particular protocols, such as I²S or TDM,
                        which package the audio into a stream of digital signals that the processor will be able to decode.
                        Control protocols are typical too, such as I²C, used for ICs to talk to each other.
                        This diagram shows one of many implementations of TDM audio comms. TDM isn't standardised, so yours may look different.
                    </textarea>
                </section>
                <section>
                    <p>I²S</p>
                    <img src="assets/i2swiring.svg">
                    <aside class="notes">
                        I²S is important here, I mentioned this is how ICs communicate audio.
                        Here we have 3 signals, sometimes you may see I²S with a 4th signal, which is
                        a master clock, used for synchronisation.
                        When the serial clock signal transitions from low to high, the serial data
                        signal is sampled. The word select effectively says which channel you're reading,
                        either the left or right. I²S only deals with stereo, though there are alternative
                        versions with more channels.
                    </aside>
                </section>
                <section>
                    <p>microcontrollers</p>
                    <img src="assets/arduino.jpg">
                    <aside class="notes">
                        A typical embedded audio product will have a microprocessor or a microcontroller
                        as the brains of the operation. I won't get into microprocessors as they're complex.
                        Microcontrollers in comparison are simple, have built-in memory, low clock speeds, not crazy powerful, but really low power.
                        Importantly, they'll be well documented, so easier to work with, especially if you're learning.
                    </aside>
                </section>
                <section data-markdown>
                    <textarea data-template data-separator-notes="^Note:">
                        ### μcontrollers
                        - low-cost dev kits
                        - reference designs
                        - peripherals
                        - datasheets (technical manuals)
                        Note: If you're working with micro controllers, it's useful to get yourself a dev kit,
                        and become acquainted with manufacturer supplied reference designs.
                        Make sure the device you're using has the peripherals you need.
                        Peripherals are dedicated hardware to do the job you need to do.
                        For example, if your micro has an I²S peripheral, you'd use it collect the audio from the ADC.
                        Datasheets are the documentation for the micro and are written an a very technical manor.
                        Reading them is a skill in itself and will improve with practise.
                    </textarea>
                </section>
                <section data-markdown>
                    <textarea data-template data-separator-notes="^Note:">
                        - EEVblog https://www.youtube.com/user/EEVblog
                        - Martin K. Schröder https://www.youtube.com/user/mkschreder
                        Note: Here's some useful youtube channels if you want to learn
                        more about electronics and embedded design.
                        EEVblog has tonnes of videos on electronics probably covering every you need.
                        Martin K. Schröder has some intense full board design videos that go through
                        the whole process using kicad. And I'm sure there are loads more.
                    </textarea>
                </section>
                <section data-markdown>
                    <textarea data-template data-separator-notes="^Note:">
                        ### baremetal programming
                        _"We demand rigidly defined areas of doubt and uncertainty!"_
                        Note: Before I move onto baremetal microcontroller programming,
                        are there any questions about anything I've covered so far?
                        We looked at analogue circuits, schematics, kicad, ADCs and ucontrollers.
                        You may wonder why you might need to program baremetal or without an OS.
                        Absolutely you may not need to write baremetal. You may well be programming
                        for an embedded linux or a real-time operating system such as freeRTOS.
                        Either way, it may be useful to know a bit about the baremetal in case you
                        find yourself having to write a very low level driver.
                    </textarea>
                </section>
                <section>
                    <p>assembly (ASM)</p>
                    <pre><code>
                        str     fp, [sp, #-4]!
                        add     fp, sp, #0
                        ldr     r3, .L3
                        ldr     r2, .L3+4
                        str     r2, [r3]
                        ldr     r3, .L3+8
                        mov     r2, #1
                        str     r2, [r3]
                        dsb
                        mov     r3, #1207959552
                        ldr     r2, .L3+12
                        ...
                    </code></pre>
                    <aside class="notes">
                        Just as schematics are the language of schematics, assembly is the language of microcontrollers.
                        Assembly language is a text representation of hardware CPU instructions, codes that the CPU understands.
                        Different devices have different dialects of assembly, and may have specific instructions.
                        As a minimum, assembly should be used to initialise the system and create the 'C abstract machine',
                        the minimum required environment to run C/C++ code.
                        We need this to get us to the 'main' function that the programmers amongst you will know as a program entry point.
                    </aside>
                </section>
                <section data-markdown>
                    <textarea data-template data-separator-notes="^Note:">
                        ### c/c++
                        - but without exceptions, runtime type information (RTTI) etc
                        - baremetal == freestanding == no operating system (OS)
                        Note: Typically, we're not going to program our entire system in assembly.
                        It's likely that we'll write in a higher-level language such as C/C++, possibly even rust or nim.
                        We can do this with some caveats. Microcontrollers have limited memory resources, so we'll likely
                        switch off features that we don't absolutely need. We also don't have the luxury of an OS,
                        so we'll need to program the hardware directly.
                    </textarea>
                </section>
                <section data-markdown>
                    <textarea data-template data-separator-notes="^Note:">
                        ### special function registers (SFRs)
                        ![](assets/sfr.svg)
                        Note: You may wonder how exactly we can control the hardware from code.
                        Microcontrollers have special memory locations that are internally connected to hardware.
                        In this example, we're saving the number 5 to a fictional 4-bit register.
                        5 in binary is 0101, and each binary value is connected to a hardware switch,
                        switching certain hardware facilities on or off.
                        To figure out which memory locations and values you need to write, you'll need to read the datasheet, so best keep it nearby.
                    </textarea>
                </section>
                <section data-markdown>
                    <textarea data-template data-separator-notes="^Note:">
                        ### tooling
                        - cross-compilers (GCC, Clang)
                        - build automation (CMake, Meson)
                        - testing (throwtheswitch.org)
                        Note: We have to cross-compile our microcontroller code, as the compilers themselves can't run on the device.
                        For this I you can use GCC or Clang, standard open source compilers.
                        Build automation is something you'll have to get to grips with, but normally
                        example projects will include this.
                        Testing baremetal, cross-compiled systems can be tricky, but check out throw the switch as they have good strategies for this.
                    </textarea>
                </section>
                <section>
                    <p>cross-compiling</p>
                    <img src="assets/crosscompile.svg">
                    <aside class="notes">
                        I said we can't run the compiler directly on our device. Generally this
                        is true, though if your target is a raspberry pi, you would be able to
                        compile on the device. However, chances are, it's going to be slow.
                        Normally, we'll cross compile our code.
                        The compiler's natural tendency is to compile for the machine that it's running
                        on. But given the cpu command line option, it will instead generate an executable
                        that isn't compatible with your development PC, but is compatible with your
                        target device, in this case a microcontroller with an ARM cortex-m7 CPU.
                    </aside>
                </section>
                <section data-background-iframe="https://godbolt.org/">
                    <aside class="notes">
                        [Paste code, set command line option to -mcpu=cortex-m7 and maybe -mthumb]
                        This is just the code snippet from my c++ talk that I mentioned. Again, don't
                        worry about reading it or trying to understand it. It's written in a purposefully
                        obscure way. Hopefully you'll never actually see code like this out there in the wild.
                        [Switch between compilers.]
                    </aside>
                </section>
                <section>
                    <p>programming & debugging</p>
                    <img src="assets/debug.svg">
                    <aside class="notes">
                        Programming and debugging our hardware is also a little tricky.
                        We've compiled code for our target processor, we can't run it locally, so we have to run it remotely.
                        For those of you used to debugging by stepping through your code line-by-line
                        will be able to do so via this simple setup.
                        A debug program such as gdb or lldb can run the program on the hardware via a hardware debugger.
                        The hardware debugger interfaces with a program such as openOCD, which serves up the hardware to gdb as if it's any other piece of software.
                    </aside>
                </section>
                <section data-markdown>
                    <textarea data-template data-separator-notes="^Note:">
                        ### embedded programming
                        _"And so the problem remained; lots of people were mean, and most were miserable, even the ones with digital watches."_
                        Note: Quick recap before we continue. We covered languages, SFRs, tools and debugging.
                        Any questions?
                    </textarea>
                </section>
                <section data-markdown>
                    <textarea data-template data-separator-notes="^Note:">
                        ### hard real-time
                        - latency requirements (time limits)
                        - memory constraints (space limits)
                        - determinism
                        Note: Those of you familiar with audio software programming
                        can think of hard real-time as being one big audio thread.
                        We have to be a little careful about what we do as we have real-time
                        constraints.
                    </textarea>
                </section>
                <section>
                    <p>interrupts</p>
                    <img src="assets/interrupts.svg">
                    <aside class="notes">
                        Interrupts are effectively callbacks triggered by hardware events and signals.
                        The tricky part is that the hardware signals may need to be serviced within a certain amount of time.
                        For example, if we've received our audio sample from the ADC via I2S,
                        we need to save that data to a buffer before the next sample arrives otherwise we'll lose data.
                        This is what I mean by latency requirements.
                    </aside>
                </section>
                <section>
                    <p>c/c++ features</p>
                    <img src="assets/memory.svg" height="600">
                    <aside class="notes">
                        Certain features are typically avoided for this reason.
                        Dynamic memory allocation is one such feature. It's really useful to able
                        to conjure arbitrary amounts of memory on-the-fly, but in an embedded system,
                        you may run out of memory, which means such allocations may fail. It can also
                        be a little too unpredictable.
                        C++ exceptions are another such feature. They are fast, but consume a lot of memory,
                        and rely on dynamic allocations. In this diagram...
                    </aside>
                </section>
                <section>
                    <p>stack overflow</p>
                    <img src="assets/overflow.svg" height="600">
                    <aside class="notes">
                        Weird things happen when you run out of memory which is entirely possible in an embedded system.
                        Your program will probably crash, but it might not, instead it may
                        just corrupt some other memory being used for something else, which
                        may still appear valid and continue running. This may result in weird, unexpected behaviours.
                        This is commonly referred to as undefined behaviour, which is something
                        you should avoid wherever possible.
                        On a PC running an OS, you're protected against this kind of thing,
                        not just because you've got GB of memory to use, so the OS can just give
                        you more memory if you need it; but also because there are safeguards in the memory,
                        so the OS knows when you've run out of memory before anything can be corrupted.
                        Your embedded device may not have such provisions, so might not be able to
                        inform the program that there's a problem. In this diagram...
                    </aside>
                </section>
                <section data-markdown>
                    <textarea data-template data-separator-notes="^Note:">
                        ### audio programming
                        _“For a moment, nothing happened. Then, after a second or so, nothing continued to happen.”_
                        Note: Next up, a quick note about audio programming on our embedded system.
                    </textarea>
                </section>
                <section>
                    <p>audio buffer</p>
                    <img src="assets/buffer.svg">
                    <aside class="notes">
                        In this example, the I²S delivers a single audio frame, which consists of a left and a right sample.
                        It may be inefficient to process the audio right away, or we may simply not have the processing time
                        to do so. Instead, we'll buffer it up. Typically we'll get a direct memory access (DMA) controller
                        to do this for us, as it's efficient.
                        In this case the buffer is filled without any control and has the left and right channels interleaved.
                    </aside>
                </section>
                <section>
                    <p>digital signal processing (DSP)</p>
                    <iframe src="https://www.desmos.com/calculator/dnzfajfpym" width="100%" height="600px"></iframe>
                    <aside class="notes">
                        Now that we've got the data we're free to do whatever we want with it.
                        We may mix it with other audio sources, filter it or apply all sorts of effects to it
                        in much the same way you would in any audio software application.
                        I've got desmos here because it's a really handy online tool for visualising your
                        signal processing.
                    </aside>
                </section>
                <section data-markdown>
                    <textarea data-template data-separator-notes="^Note:">
                        ### output
                        _“If they don't keep on exercising their lips, he thought, their brains start working.”_
                        Note: We've got our data, processed it, given it a delay and some amp modelling.
                        Now all we need to do it get it out of the confines of our embedded system.
                    </textarea>
                </section>
                <section data-markdown>
                    <textarea data-template data-separator-notes="^Note:">
                        ### usb
                        - high speed, differential signals
                        - specific clock speeds
                        - examples
                        - beyondlogic.org/usbnutshell
                        Note: Our microcontroller may have a USB peripheral, in which case we can both send and
                        receive audio from a host PC. If you're going to get into USB, make sure you know a little
                        about high speed, differential signals. USB signals run at high speeds, so your PCB layout
                        is important. Make use of examples out there on the internet, there are lots.
                        And check out USB in a nutshell, a really handy online book that explains the inner workings of USB.
                    </textarea>
                </section>
                <section data-background="assets/codec.jpg">
                    <aside class="notes">
                        The obvious option is to simply output our audio back out to the analogue domain.
                        This is a audio CODEC device, featured on a low cost development kit. It has both
                        audio inputs and audio outputs, both of which interface with a microcontroller.
                        We could also use an independent digital-to-analogue device which would do the output side only.
                        This would work in much the same way as our ADC, only flowing in the other direction. In this schematic...
                    </aside>
                </section>
                <!-- <section data-markdown>
                    <textarea data-template data-separator-notes="^Note:">
                        ### conclusion
                        _"A common mistake that people make when trying to design something completely foolproof is to underestimate the ingenuity of complete fools."_
                        Note: Hopefully some of what I've mentioned will be of some use.
                        Some final thoughts. If you're starting an embedded audio project like this,
                        find some low cost development kits that have most or all of the hardware you
                        think you'll need. They'll serve as both a development platform for you to
                        write your embedded software, and an example for your own hardware designs.
                        Also, look around on the internet for tutorials and forums for help. Youtube
                        has tonnes of useful videos on electronics, dsp and the rest.
                    </textarea>
                </section> -->
                <section data-markdown>
                    <textarea data-template data-separator-notes="^Note:">
                        ### conclusion
                        _"A common mistake that people make when trying to design something completely foolproof is to underestimate the ingenuity of complete fools."_
                        Note: Hopefully some of what I've mentioned will be of some use.
                        Some final thoughts.
                    </textarea>
                </section>
                <section data-markdown>
                    <textarea data-template data-separator-notes="^Note:">
                        ![](assets/origind.svg)
                        Note: At the beginning of the talk I mentioned my old usb synth design.
                    </textarea>
                </section>
                <section data-background-image="assets/devkit.jpg">
                    <!--  -->
                    <aside class="notes">
                        It turns out there is a $50 dev kit that has all of the hardware on that design and more.
                        This is just one example, I'm sure there are others. But this is the sort
                        of thing that I would get if I was starting out. Program it with arduino,
                        or just modify the example programs that it comes with.
                    </aside>
                </section>
                <section>
                    <p>just do software?</p>
                    <img src="assets/software.jpg">
                    <aside class="notes">
                        Hardware is pretty hard, but great fun. There's a whole 'nother level
                        beyond what I've talked about which is designing for manufacture which
                        gets really hairy and can be extremely expensive.
                        You'll want to be really sure that you need hardware if you're going
                        to set down this path.
                    </aside>
                </section>
                <section data-markdown>
                    <textarea data-template data-separator-notes="^Note:">
                        #### quotes were all from Douglas Adams' The Hitchhiker's Guide to the Galaxy
                        #### github.com/baremetaldev/adc20
                        #### baremetal.dev (coming soon)
                        #### @tomjwaldron
                    </textarea>
                </section>
            </div>
        </div>

        <script src="reveal.js/dist/reveal.js"></script>
        <script src="reveal.js/plugin/notes/notes.js"></script>
        <script src="reveal.js/plugin/markdown/markdown.js"></script>
        <script src="reveal.js/plugin/highlight/highlight.js"></script>
        <script>
            // More info about initialization & config:
            // - https://revealjs.com/initialization/
            // - https://revealjs.com/config/
            Reveal.initialize({
                hash: true,

                // Learn about plugins: https://revealjs.com/plugins/
                plugins: [ RevealMarkdown, RevealHighlight, RevealNotes ]
            });
        </script>

<style>
    .reveal h1, .reveal h2, .reveal h3, .reveal h4, .reveal h5 {
                  text-transform: none;
		  }
</style>
    </body>
</html>
